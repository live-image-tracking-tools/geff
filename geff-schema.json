{
  "$defs": {
    "Axis": {
      "description": "The axes list is modeled after the\n[OME-zarr](https://ngff.openmicroscopy.org/0.5/index.html#axes-md)\nspecifications and is used to identify spatio-temporal properties on the\ngraph nodes.\n\nThe `name` must be an existing attribute on the nodes. The optional `type` key\nmust be one of `space`, `time` or `channel`, though readers may not use this information.\nAn optional `unit` key should match the valid OME-Zarr units and `min` and `max` keys\ndefine the range of the axis\n\nThe optional `scale` field can be used to store a scaling factor such as converting\nthe data from pixel space into real world units. The associated, optional `scaled_unit`\nfield specifies the output unit after applying `scale` to the data.",
      "properties": {
        "name": {
          "description": "Name of the corresponding node property",
          "title": "Name",
          "type": "string"
        },
        "type": {
          "anyOf": [
            {
              "enum": [
                "space",
                "time",
                "channel"
              ],
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "The type of data encoded in this axis, one of ('space', 'time', 'channel') or None",
          "title": "Type"
        },
        "unit": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "enum": [
                "angstrom",
                "attometer",
                "centimeter",
                "decimeter",
                "exameter",
                "femtometer",
                "foot",
                "gigameter",
                "hectometer",
                "inch",
                "kilometer",
                "megameter",
                "meter",
                "micrometer",
                "mile",
                "millimeter",
                "nanometer",
                "parsec",
                "petameter",
                "picometer",
                "terameter",
                "yard",
                "yoctometer",
                "yottameter",
                "zeptometer",
                "zettameter",
                "pixel"
              ],
              "type": "string"
            },
            {
              "enum": [
                "attosecond",
                "centisecond",
                "day",
                "decisecond",
                "exasecond",
                "femtosecond",
                "gigasecond",
                "hectosecond",
                "hour",
                "kilosecond",
                "megasecond",
                "microsecond",
                "millisecond",
                "minute",
                "nanosecond",
                "petasecond",
                "picosecond",
                "second",
                "terasecond",
                "yoctosecond",
                "yottasecond",
                "zeptosecond",
                "zettasecond",
                "frame"
              ],
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional, the unit for this axis. If the type is 'space' or 'time', we recommend utilizing the OME-NGFF spatial or temporal units respectively.",
          "title": "Unit"
        },
        "min": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional, the minimum value for this axis.",
          "title": "Min"
        },
        "max": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional, the minimum value for this axis.",
          "title": "Max"
        },
        "scale": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional, a scaling factor that can be applied to the data",
          "title": "Scale"
        },
        "scaled_unit": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "enum": [
                "angstrom",
                "attometer",
                "centimeter",
                "decimeter",
                "exameter",
                "femtometer",
                "foot",
                "gigameter",
                "hectometer",
                "inch",
                "kilometer",
                "megameter",
                "meter",
                "micrometer",
                "mile",
                "millimeter",
                "nanometer",
                "parsec",
                "petameter",
                "picometer",
                "terameter",
                "yard",
                "yoctometer",
                "yottameter",
                "zeptometer",
                "zettameter",
                "pixel"
              ],
              "type": "string"
            },
            {
              "enum": [
                "attosecond",
                "centisecond",
                "day",
                "decisecond",
                "exasecond",
                "femtosecond",
                "gigasecond",
                "hectosecond",
                "hour",
                "kilosecond",
                "megasecond",
                "microsecond",
                "millisecond",
                "minute",
                "nanosecond",
                "petasecond",
                "picosecond",
                "second",
                "terasecond",
                "yoctosecond",
                "yottasecond",
                "zeptosecond",
                "zettasecond",
                "frame"
              ],
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional, the unit after applying the `scale` value to the data. If `scaled_unit` is set, a `scale` value must also be provided.",
          "title": "Scaled Unit"
        }
      },
      "required": [
        "name"
      ],
      "title": "Axis",
      "type": "object"
    },
    "DisplayHint": {
      "description": "Metadata indicating how spatiotemporal axes are displayed by a viewer",
      "properties": {
        "display_horizontal": {
          "description": "Which spatial axis to use for horizontal display",
          "title": "Display Horizontal",
          "type": "string"
        },
        "display_vertical": {
          "description": "Which spatial axis to use for vertical display",
          "title": "Display Vertical",
          "type": "string"
        },
        "display_depth": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional, which spatial axis to use for depth display",
          "title": "Display Depth"
        },
        "display_time": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional, which temporal axis to use for time",
          "title": "Display Time"
        }
      },
      "required": [
        "display_horizontal",
        "display_vertical"
      ],
      "title": "DisplayHint",
      "type": "object"
    },
    "GeffMetadata": {
      "description": "Geff metadata schema to validate the attributes json file in a geff zarr",
      "properties": {
        "geff_version": {
          "description": "Geff version string following semantic versioning (MAJOR.MINOR.PATCH), optionally with .devN and/or +local parts (e.g., 0.3.1.dev6+g61d5f18).\nIf not provided, the version will be set to the current geff package version.",
          "pattern": "^\\d+\\.\\d+(?:\\.\\d+)?(?:\\.dev\\d+)?(?:\\+[a-zA-Z0-9]+)?",
          "title": "Geff Version",
          "type": "string"
        },
        "directed": {
          "description": "True if the graph is directed, otherwise False.",
          "title": "Directed",
          "type": "boolean"
        },
        "axes": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/Axis"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional list of `Axis` objects defining the axes of each node\n            in the graph. The axes list is modeled after the\n            [OME-zarr](https://ngff.openmicroscopy.org/0.5/index.html#axes-md)\n            specifications and is used to identify spatio-temporal properties on the\n            graph nodes. If the same names are used in the axes metadata of the\n            related image or segmentation data, applications can use this information\n            to align graph node locations with image data.\n            The order of the axes in the list is meaningful. For one, any downstream\n            properties that are an array of values with one value per (spatial) axis\n            will be in the order of the axis list (filtering to only the spatial axes by\n            the `type` field if needed). Secondly, if associated image or segmentation\n            data does not have axes metadata, the order of the spatiotemporal axes is a\n            good default guess for aligning the graph and the image data, although there\n            is no way to denote the channel dimension in the graph spec. If you are\n            writing out a geff with an associated segmentation and/or image dataset, we\n            highly recommend providing the axis names for your segmentation/image using\n            the OME-zarr spec, including channel dimensions if needed.",
          "title": "Axes"
        },
        "node_props_metadata": {
          "additionalProperties": {
            "$ref": "#/$defs/PropMetadata"
          },
          "description": "Metadata for node properties. The keys are the property identifiers, and the values are PropMetadata objects describing the properties.There must be one entry for each node property.",
          "title": "Node Props Metadata",
          "type": "object"
        },
        "edge_props_metadata": {
          "additionalProperties": {
            "$ref": "#/$defs/PropMetadata"
          },
          "description": "Metadata for edge properties. The keys are the property identifiers, and the values are PropMetadata objects describing the properties.There must be one entry for each edge property.",
          "title": "Edge Props Metadata",
          "type": "object"
        },
        "sphere": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "\n            Name of the optional `sphere` property.\n\n            A sphere is defined by\n\n            - a center point, already given by the `space` type properties\n            - a radius scalar, stored in this property\n            ",
          "title": "Node property: Detections as spheres"
        },
        "ellipsoid": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "\n            Name of the `ellipsoid` property.\n\n            An ellipsoid is assumed to be in the same coordinate system as the `space` type\n            properties.\n\n            It is defined by\n\n            - a center point $c$, already given by the `space` type properties\n            - a covariance matrix $\\Sigma$, symmetric and positive-definite, stored in this\n              property as a `2x2`/`3x3` array.\n\n            To plot the ellipsoid:\n\n            - Compute the eigendecomposition of the covariance matrix\n            $\\Sigma = Q \\Lambda Q^{\\top}$\n            - Sample points $z$ on the unit sphere\n            - Transform the points to the ellipsoid by\n            $x = c + Q \\Lambda^{(1/2)} z$.\n            ",
          "title": "Node property: Detections as ellipsoids"
        },
        "track_node_props": {
          "anyOf": [
            {
              "additionalProperties": {
                "type": "string"
              },
              "propertyNames": {
                "enum": [
                  "lineage",
                  "tracklet"
                ]
              },
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Node properties denoting tracklet and/or lineage IDs.\nA tracklet is defined as a simple path of connected nodes where the initiating node has any incoming degree and outgoing degree at most 1, and the terminating node has incoming degree at most 1 and any outgoing degree, and other nodes along the path have in/out degree of 1. Each tracklet must contain the maximal set of connected nodes that match this definition - no sub-tracklets.\nA lineage is defined as a weakly connected component on the graph.\nThe dictionary can store one or both of 'tracklet' or 'lineage' keys.",
          "title": "Track Node Props"
        },
        "related_objects": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/RelatedObject"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "A list of dictionaries of related objects such as labels or images. Each dictionary must contain 'type', 'path', and optionally 'label_prop' properties. The 'type' represents the data type. 'labels' and 'image' should be used for label and image objects, respectively. Other types are also allowed, The 'path' should be relative to the geff zarr-attributes file. It is strongly recommended all related objects are stored as siblings of the geff group within the top-level zarr group. The 'label_prop' is only valid for type 'labels' and specifies the node property that will be used to identify the labels in the related object. ",
          "title": "Related Objects"
        },
        "display_hints": {
          "anyOf": [
            {
              "$ref": "#/$defs/DisplayHint"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Metadata indicating how spatiotemporal axes are displayed by a viewer"
        },
        "extra": {
          "additionalProperties": true,
          "description": "The optional `extra` object is a free-form dictionary that can hold any additional, application-specific metadata that is **not** covered by the core geff schema. Users may place arbitrary keys and values inside `extra` without fear of clashing with future reserved fields. Although the core `geff` reader makes these attributes available, their meaning and use are left entirely to downstream applications. ",
          "title": "Extra",
          "type": "object"
        }
      },
      "required": [
        "directed",
        "node_props_metadata",
        "edge_props_metadata",
        "geff_version"
      ],
      "title": "geff_metadata",
      "type": "object"
    },
    "PropMetadata": {
      "description": "Each property must have a string identifier (the group name for the\nproperty) and a dtype. The dtype can be any string\nthat can be coerced into a numpy dtype, or the special `varlength` dtype\nindicating this is a variable length property (coming soon). String properties\nshould have dtype `str`, not `varlength`, even though they are stored using the\nsame variable length mechanism.",
      "properties": {
        "identifier": {
          "description": "Identifier of the property. Must be unique within its own component subgroup (nodes or edges). Must be a non-empty string.",
          "minLength": 1,
          "title": "Identifier",
          "type": "string"
        },
        "dtype": {
          "description": "Data type of the property. Must be a non-empty string that can be parsed into a numpy dtype.Examples of valid values: 'int', 'int16', 'float64', 'str', 'bool'. Examples of invalid values: 'integer', 'np.int16', 'number', 'string'.",
          "minLength": 1,
          "title": "Dtype",
          "type": "string"
        },
        "varlength": {
          "default": false,
          "description": "True if the property contains variable length arrays. Variable length arrays cannot be of dtype string (e.g. you cannot have a property where each node has an array of strings)",
          "title": "Varlength",
          "type": "boolean"
        },
        "unit": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional unit of the property.",
          "title": "Unit"
        },
        "name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional human friendly name of the property",
          "title": "Name"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Optional description of the property.",
          "title": "Description"
        }
      },
      "required": [
        "identifier",
        "dtype"
      ],
      "title": "PropMetadata",
      "type": "object"
    },
    "RelatedObject": {
      "description": "A set of metadata for data that is associated with the graph. The types\n'labels' and 'image' should be used for label and image objects, respectively.\nOther types are also allowed.",
      "properties": {
        "type": {
          "description": "Type of the related object. 'labels' for label objects, 'image' for image objects. Other types are also allowed, but may not be recognized by reader applications. ",
          "title": "Type",
          "type": "string"
        },
        "path": {
          "description": "Path of the related object within the zarr group, relative to the geff zarr-attributes file. It is strongly recommended all related objects are stored as siblings of the geff group within the top-level zarr group.",
          "title": "Path",
          "type": "string"
        },
        "label_prop": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Property name for label objects. This is the node property that will be used to identify the labels in the related object. This is only valid for type 'labels'.",
          "title": "Label Prop"
        }
      },
      "required": [
        "type",
        "path"
      ],
      "title": "RelatedObject",
      "type": "object"
    }
  },
  "properties": {
    "geff": {
      "$ref": "#/$defs/GeffMetadata",
      "description": "geff_metadata"
    }
  },
  "required": [
    "geff"
  ],
  "title": "GeffSchema",
  "type": "object"
}